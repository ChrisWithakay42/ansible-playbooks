---
- name: Play 1 - Install prerequisites on all nodes
  hosts: all
  become: yes
  gather_facts: no
  roles:
    - role: common

- name: Play 2 Install the first k3s master
  hosts: k3s_masters[0]
  become: yes
  roles:
    - role: k3s_master

# Note: We can combine installing other masters and agents if the logic is similar,
# or keep them separate for clarity. Here we assume you might want different logic later.
# For now, let's keep the original logic for joining other masters here.
- name: Play 3 - Install other masters and agents
  hosts: k3s_masters:!{{ groups['k3s_masters'][0] }}, k3s_agents
  become: yes
  # These vars are needed for the tasks below
  vars:
    token: "{{ hostvars[groups['k3s_masters'][0]]['k3s_node_token'] }}"
    master_ip: "{{ hostvars[groups['k3s_masters'][0]]['ansible_host'] | default(hostvars[groups['k3s_masters'][0]]['inventory_hostname']) }}"
  tasks:
    # This part is for joining other masters. It's kept here for now.
    # If it grows, it could become its own role: `k3s_master_join`.
    - name: Join other masters to the cluster
      when: inventory_hostname in groups['k3s_masters']
      block:
        - name: Create k3s configuration directory on joining masters
          ansible.builtin.file:
            path: /etc/rancher/k3s
            state: directory
            owner: root
            group: root
            mode: '0755'

        - name: Create k3s config.yaml for other masters
          ansible.builtin.copy:
            content: |
              server: https://{{ master_ip }}:6443
              token: {{ token }}
              flannel-backend: "none"
              disable-kube-proxy: true
            dest: /etc/rancher/k3s/config.yaml
            owner: root
            group: root
            mode: '0644'

        - name: Download k3s installer script on joining masters
          ansible.builtin.get_url:
            url: https://get.k3s.io
            dest: /tmp/k3s-installer.sh
            mode: '0755'
        
        # Original task was commented out, uncomment if needed
        # - name: Install k3s on other masters
        #   ansible.builtin.command: /tmp/k3s-installer.sh server
        #   args:
        #     creates: /etc/systemd/system/k3s.service

    # The agent logic is now handled by the k3s_agent role
    - name: Join agent nodes to the cluster
      when: inventory_hostname in groups['k3s_agents']
      ansible.builtin.include_role:
        name: k3s_agent

- name: Play 4 - Install and Validate Cilium CNI
  hosts: k3s_masters[0]
  become: yes
  roles:
    - role: cilium

- name: Play 5 - Fetch kubeconfig to local machine
  hosts: k3s_masters[0]
  gather_facts: no
  vars:
    kubeconfig_user: pi
  tasks:
    - name: Remove existing local kubeconfig if it exists
      ansible.builtin.file:
        path: "~/.kube/config"
        state: absent
      delegate_to: localhost

    - name: Fetch the modified kubeconfig from the master
      ansible.builtin.fetch:
        src: "/home/{{ kubeconfig_user }}/.kube/config"
        dest: "~/.kube/config"
        flat: yes

- name: Play 6 Deploy mandatory Helm charts
  hosts: k3s_masters[0]
  vars:
    kubeconfig_user: pi
  environment:
    KUBECONFIG: "/home/{{ kubeconfig_user }}/.kube/config"
  roles:
    - role: helm_charts

- name: Play 7 - Configure Vault and External Secrets Operator Integration
  hosts: k3s_masters[0]
  become: no # These tasks run as the kubeconfig user
  vars:
    kubeconfig_user: pi # Or whatever user you have defined
  environment:
    KUBECONFIG: "/home/{{ kubeconfig_user }}/.kube/config"
  tasks:
    - name: Wait for the Vault pod to be in a Running state
      kubernetes.core.k8s_info:
        kind: Pod
        name: vault-0
        namespace: vault
        wait: yes
        wait_condition:
          type: Ready
          status: "True"
        wait_timeout: 300
      register: vault_pod_status
  
    - name: Enable the Vault Kubernetes auth method
      ansible.builtin.command:
        cmd: "kubectl exec -n vault vault-0 -- vault auth enable kubernetes"
      register: vault_auth_enable
      # This command fails if auth is already enabled, so we check the output.
      # This makes the task idempotent.
      failed_when: "'path is already in use' not in vault_auth_enable.stderr and vault_auth_enable.rc != 0"
      changed_when: "'Success!' in vault_auth_enable.stdout"
  
    - name: Configure the Vault Kubernetes auth method
      ansible.builtin.command:
        # Vault can auto-discover these settings from within the pod's environment
        cmd: >
          kubectl exec -n vault vault-0 --
          vault write auth/kubernetes/config
          kubernetes_host="https://kubernetes.default.svc"
          kubernetes_ca_cert=@/var/run/secrets/kubernetes.io/serviceaccount/ca.crt
      changed_when: true # The write command doesn't indicate change, so we assume it.
  
    - name: Create a Vault policy for External Secrets to read secrets
      ansible.builtin.command:
        # This policy grants read-only access to all secrets under the default kv-v2 engine path
        cmd: >
          kubectl exec -n vault vault-0 --
          vault policy write eso-policy - <<EOF
          path "secret/data/*" {
            capabilities = ["read"]
          }
          EOF
      changed_when: true
  
    - name: Create a Vault role for the External Secrets service account
      ansible.builtin.command:
        cmd: >
          kubectl exec -n vault vault-0 --
          vault write auth/kubernetes/role/external-secrets
          bound_service_account_names=external-secrets
          bound_service_account_namespaces=external-secrets
          policies=eso-policy
          ttl=24h
      changed_when: true
  
    - name: Create the ClusterSecretStore for ESO to connect to Vault
      kubernetes.core.k8s:
        state: present
        definition:
          apiVersion: external-secrets.io/v1beta1
          kind: ClusterSecretStore
          metadata:
            name: vault-backend
          spec:
            provider:
              vault:
                # The service address for the Vault instance
                server: "http://vault.vault.svc.cluster.local:8200"
                # The path for the kv-v2 secrets engine
                path: "secret"
                version: "v2"
                auth:
                  # This section tells ESO to use the Kubernetes auth method
                  kubernetes:
                    # This must match the role we created in Vault
                    role: "external-secrets"
                    # The mount path where the k8s auth method is enabled
                    mountPath: "kubernetes"
                    # ESO will use its own service account for authentication
                    serviceAccountRef:
                      name: external-secrets
                      namespace: external-secrets
